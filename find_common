#!/usr/bin/env perl
use strict;
use warnings;

use Digest::MD5 qw(md5_hex);
use Readonly::Values::Months;	# e.g., $JAN == 1, $FEB == 2, etc.
use Gedcom;

# Hash of people by file
my %people_by_file;

# Index: key = md5(birth + death) -> [ [file, person], ... ]
my %match_index;

foreach my $ged_file (@ARGV) {
    my $ged;
    eval {
    	$ged = Gedcom->new(gedcom_file => $ged_file, read_only => 1);
    };
    if($@) {
	warn "Failed to parse $ged_file: $@";
	next;
    }

    my @individuals = $ged->individuals;
    foreach my $indi (@individuals) {
	my $name;
	eval {
		$name = $indi->name();
	};
	next unless $name;
	my $birth;
	eval {
		$birth = $indi->get_value('birth date');
	};
	# Only consider people with both birth and death dates
	next unless defined($birth);
	my $death;
	eval {
		$death = $indi->get_value('death date');
	};

	next unless defined $death;

	$birth = normalize_date($birth);
	$death = normalize_date($death);
	my $key = generate_key($birth, $death);

	push @{ $match_index{$key} }, [$ged_file, $indi];
	push @{ $people_by_file{$ged_file} }, $indi;
    }
}

# Output matches
print "People with matching birth and death dates across files:\n";

foreach my $key (sort keys %match_index) {
    my @matches = @{ $match_index{$key} };
    next unless @matches > 1;

    print "\nMATCH: Birth/Death Key [$key]\n";
    foreach my $match (@matches) {
        my ($file, $person) = @$match;
        my $name  = $person->name;
        my $birth = $person->get_value("birth date");
        my $death = $person->get_value("death date");
        print " - $file: $name (b. $birth, d. $death)\n";
    }
}

sub generate_key {
	my ($birth, $death) = @_;
	$birth =~ s/\s+/ /g;
	$death =~ s/\s+/ /g;
	return md5_hex(lc($birth) . lc($death));
}

sub normalize_date {
    my $date = $_[0];
    return '' unless defined $date;

    $date =~ s/^\s+|\s+$//g;
    $date = uc $date;

    # Match GEDCOM-like date formats: 1 JAN 1900, JAN 1900, 1900
    if ($date =~ /^(\d{1,2})\s+([A-Z]{3,})\s+(\d{4})$/) {
        my ($day, $mon, $year) = ($1, $2, $3);
        $mon = month_to_number($mon) // '00';
        return sprintf("%04d-%02d-%02d", $year, $mon, $day);
    }
    elsif ($date =~ /^([A-Z]{3,})\s+(\d{4})$/) {
        my ($mon, $year) = ($1, $2);
        $mon = month_to_number($mon) // '00';
        return sprintf("%04d-%02d", $year, $mon);
    }
    elsif ($date =~ /^(\d{4})$/) {
        return $date;
    }

    # Unrecognized format, return as-is
    return $date;
}

sub month_to_number {
	return $months{lc($_[0])};
}
